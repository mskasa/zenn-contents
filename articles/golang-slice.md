---
title: "Go言語 スライスの内部構造とパフォーマンスについて理解する"
emoji: "🚀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [go]
published: false
---

## 概要

## スライスの構造
スライスの実態は構造体で、以下の3つのフィールドを持ちます。

1. ポインタ（配列へのポインタ）
1. 長さ（スライスの現在の要素数）
1. 容量（スライスが参照する配列の最大要素数）

```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```
[Goソースコード内のslice.go](https://github.com/golang/go/blob/master/src/runtime/slice.go#L15-L19)より

スライスは配列を便利にラップしたもので、動的にサイズが変更できる点が特徴です。そのため、固定サイズの配列と異なり、要素の追加や削除が簡単に行えます。この柔軟性により、Go言語ではスライスが一般的に使用されます。

## スライスとパフォーマンス

スライスの容量が不足した場合、新しい配列が自動的に割り当てられ、既存の要素が新しい配列にコピーされます。これにより、スライスのサイズを動的に拡張できますが、この内部で発生するコピー操作がパフォーマンスに影響することがあります。そのため、特に大規模なデータを扱う際には、初期容量を適切に設定することが重要です。適切な容量の設定により、不要なメモリ再割り当てとコピーの回数を減らし、効率的なメモリ管理が可能になります。

### 例：スライスの容量不足と再割り当て

以下に、スライスの容量不足時に新しい配列が割り当てられ、既存の要素がコピーされる具体的なコード例とその実行結果を示します。

```go
package main

import (
    "fmt"
    "unsafe"
)

func main() {
    slice := make([]int, 0, 2)
    printSliceInfo("初期スライス", slice)
    
    for i := 1; i <= 5; i++ {
        slice = append(slice, i)
        printSliceInfo(fmt.Sprintf("追加後 %d", i), slice)
    }
}

func printSliceInfo(label string, s []int) {
    fmt.Printf("%s - 長さ: %d, 容量: %d, ポインタ: %p, 要素: %v\n", label, len(s), cap(s), s, s)
}
```

```
初期スライス - 長さ: 0, 容量: 2, ポインタ: 0xc00010e010, 要素: []
追加後 1 - 長さ: 1, 容量: 2, ポインタ: 0xc00010e010, 要素: [1]
追加後 2 - 長さ: 2, 容量: 2, ポインタ: 0xc00010e010, 要素: [1 2]
追加後 3 - 長さ: 3, 容量: 4, ポインタ: 0xc000122000, 要素: [1 2 3]
追加後 4 - 長さ: 4, 容量: 4, ポインタ: 0xc000122000, 要素: [1 2 3 4]
追加後 5 - 長さ: 5, 容量: 8, ポインタ: 0xc000124000, 要素: [1 2 3 4 5]
```

この結果から、スライスの容量が不足すると新しい配列が割り当てられ、容量が2倍に拡張されていることが分かります。特に、容量が2から4、そして8に増加する際に、配列のポインタが変わっている点に注目してください。これにより、新しい配列が作成され、既存の要素が新しい配列にコピーされていることが確認できます。

## スライスの容量不足に対する対策

### 1. 初期容量の適切な設定
スライスを作成する際に、予想される最大要素数を考慮して初期容量を設定することが重要です。これにより、再割り当てとコピーの回数を減らすことができます。以下に、make関数を使用して初期容量を設定する例を示します。

```go
// 予想される最大要素数が100の場合
slice := make([]int, 0, 100)
このようにすることで、スライスが初期容量内であればメモリ再割り当てが発生しないため、パフォーマンスが向上します。
```

### 2. 構造体のスライスではなくポインタのスライスを使用する
フィールドの多い構造体の場合、構造体のスライスを使用すると再割り当て時に多くのデータをコピーする必要があります。これを避けるために、構造体のスライスではなく構造体のポインタのスライスを使用することを検討します。

```go
package main

import "fmt"

type Employee struct {
	ID   int
	Name string
	Age  int
	// 他のフィールド
}

func main() {
	// 構造体のスライスを使用する場合
	var employees1 []Employee

	for i := 1; i <= 5; i++ {
		employees1 = append(employees1, Employee{
			ID:   i,
			Name: fmt.Sprintf("Employee %d", i),
			Age:  20 + i,
		})
	}
	fmt.Println("構造体のスライス:", employees1)

	// 構造体のポインタのスライスを使用する場合
	var employees2 []*Employee

	for i := 1; i <= 5; i++ {
		employees2 = append(employees2, &Employee{
			ID:   i,
			Name: fmt.Sprintf("Employee %d", i),
			Age:  20 + i,
		})
	}
	fmt.Println("構造体のポインタのスライス:", employees2)
}
```

実行結果
```
構造体のスライス: [{1 Employee 1 21} {2 Employee 2 22} {3 Employee 3 23} {4 Employee 4 24} {5 Employee 5 25}]
構造体のポインタのスライス: [0xc0000680e0 0xc000068100 0xc000068120 0xc000068160 0xc000068180]
```

データ量の減少についての説明
この結果から、構造体のポインタのスライスを使用することで、メモリ効率が向上していることがわかります。具体的には、以下の点に注目できます：

構造体のスライス:

各エントリは構造体全体を含んでいます。例えば、{1 Employee 1 21}というエントリは、ID, Name, Ageなどのすべてのフィールドを含む構造体です。
構造体のサイズが大きくなるほど、スライスの容量が不足した際に再割り当てとコピーのコストが増加します。
構造体のポインタのスライス:

各エントリは構造体のポインタを含んでいます。例えば、0xc0000680e0は構造体へのポインタです。
再割り当て時にコピーされるのはポインタのみであり、ポインタのサイズは固定です。このため、データ量が大幅に減少します。
これにより、構造体のポインタのスライスを使用することで、メモリ使用量が抑えられ、再割り当て時のパフォーマンスが向上することがわかります。特に大規模なデータセットやフィールドの多い構造体を扱う場合に有効です。




背景：
Goのスライス（slice）は動的な配列で、容量（capacity）と長さ（length）を持っています。スライスの容量を超えて新しい要素を追加（append）すると、内部的には新しいバッファが割り当てられ、既存の要素が全て新しいバッファにコピーされます。

解説：
append 関数でスライスに要素を追加する際、スライスの容量（cap）が不足していると、新しいバッファが作成され、元のスライスの全ての要素が新しいバッファにコピーされます。
これは特に大きなスライスではパフォーマンスに影響を与える可能性があります。
[]*AccountKey（ポインタのスライス）を使用する理由は、ポインタは固定サイズ（通常8バイト）なので、コピーされるデータ量が少なくて済むためです。これにより、メモリの使用効率が良くなり、コピー操作のコストが低減されます。


スライスの容量が不足した場合、新しい配列が自動的に割り当てられ、既存の要素が新しい配列にコピーされます。


---

書きたいことメモ
- スライスの構造
- スライスの宣言方法
- スライスのコピー方法
  - 変数代入
  - 関数の引数として渡す時
  - clone
  - copy
  - append
- appendの挙動
- 関数にスライス渡す時のお作法

## スライスの構造

https://github.com/golang/go/blob/master/src/runtime/slice.go#L15-L19

### 配列

「Goでは配列を使わずにスライスを使いましょう」とは色々な
え…？じゃあ何で配列なんてあるの？いらなくない？

配列はスライスの内部で使われているからです。
要するに、スライスは配列のラッパーです。便利なラッパーな方を使おうね、それだけです。

## スライスの生成方法

### 初期値がある場合
```go
s := []int{1, 2, 3}
```

### バッファ
バッファを再利用
一度メモリ領域を確保するだけで済む

### それ以外




## 関数の引数としてスライスを渡す

### Go は値渡し

> As in all languages in the C family, everything in Go is passed by value. That is, a function always gets a copy of the thing being passed, as if there were an assignment statement assigning the value to the parameter. (引用元：https://go.dev/doc/faq#pass_by_value)

Goでは、関数に引数を渡した際、必ず引数の値のコピーを作成します。参照渡しはありません。

関数内のappend()に注意する
